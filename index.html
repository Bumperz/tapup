<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tap Up – HTML5 Canvas</title>
  <style>
    :root {
      --bg: #0b0f14;
      --fg: #e8f0ff;
      --accent: #6cf;
      --muted: #99a7bd;
      --danger: #ff6b6b;
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      overscroll-behavior: none;
    }
    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { display: block; width: min(100vw, 600px); height: calc(min(100vw, 600px) * 1.6); max-height: 100vh; background: linear-gradient(#0b1320, #0b0f14); border-radius: 18px; box-shadow: 0 10px 40px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.05); touch-action: none; }

    .hud { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 14px; align-items: center; font-weight: 600; }
    .pill { background: rgba(255,255,255,.08); padding: 8px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,.08); }

    .overlay { position: fixed; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .card { pointer-events: auto; width: min(90vw, 420px); background: rgba(15,20,30,.8); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,.08); border-radius: 16px; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,.5); text-align: center; }
    .title { font-size: 28px; font-weight: 800; letter-spacing: .3px; margin: 4px 0 8px; }
    .muted { color: var(--muted); font-size: 14px; }
    .btns { display: flex; gap: 10px; justify-content: center; margin-top: 14px; flex-wrap: wrap; }
    button { cursor: pointer; border: 0; border-radius: 12px; padding: 10px 14px; font-weight: 700; }
    .primary { background: var(--accent); color: #001018; }
    .ghost { background: transparent; color: var(--fg); border: 1px solid rgba(255,255,255,.15); }
    .danger { background: var(--danger); color: white; }

    @media (max-height: 700px) {
      canvas { height: 100vh; width: calc(100vh / 1.6); }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
  </div>
  <div class="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Best: <span id="best">0</span></div>
  </div>
  <div class="overlay" id="overlay" hidden>
    <div class="card" id="startCard">
      <div class="title">Tap Up ⚽</div>
      <div class="muted">Tap (or click) the <b>ball</b> to keep it in the air. If it hits the ground, game over.</div>
      <div class="btns">
        <button class="primary" id="playBtn">Play</button>
        <button class="ghost" id="howBtn">How to play</button>
      </div>
    </div>
    <div class="card" id="howCard" hidden>
      <div class="title">How to Play</div>
      <div class="muted" style="text-align:left">
        <ul>
          <li>Tap/click <b>on the ball</b> to kick it upward.</li>
          <li>Kicks are stronger the closer you tap to the ball center.</li>
          <li>Adds slight sideways spin based on where you tap.</li>
          <li><b>Miss</b> the ball and it will fall. If it touches the ground, you lose.</li>
          <li>+1 score per successful kick. Try to beat your high score!</li>
        </ul>
      </div>
      <div class="btns">
        <button class="primary" id="howPlayBtn">Got it</button>
        <button class="ghost" id="backBtn">Back</button>
      </div>
    </div>
    <div class="card" id="gameOverCard" hidden>
      <div class="title">Game Over</div>
      <div class="muted">Final score: <b id="finalScore">0</b></div>
      <div class="btns">
        <button class="primary" id="retryBtn">Play Again</button>
        <button class="ghost" id="menuBtn">Menu</button>
        <button class="danger" id="resetBestBtn">Reset Best</button>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Fixed logical resolution (scaled by DPR) for crisp art
    const LOGICAL_W = 375; // iPhone-ish width
    const ASPECT = 1.6; // 375x600
    const LOGICAL_H = Math.round(LOGICAL_W * ASPECT);

    let dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));

    function resize() {
      const maxW = Math.min(window.innerWidth, 600);
      const maxH = Math.min(window.innerHeight, Math.round(600*ASPECT));
      // Keep logical size fixed; scale with DPR for sharpness
      canvas.style.width = Math.min(maxW, Math.round(maxH/ASPECT)) + 'px';
      canvas.style.height = Math.round(parseFloat(canvas.style.width) * ASPECT) + 'px';
      canvas.width = Math.round(LOGICAL_W * dpr);
      canvas.height = Math.round(LOGICAL_H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Game state
    const gravity = 0.35; // downward accel
    const groundY = LOGICAL_H - 40; // ground line

    const ball = {
      x: LOGICAL_W/2,
      y: LOGICAL_H/2,
      r: 26,
      vx: 0,
      vy: 0,
      spin: 0,
      angle: 0,
    };

    let score = 0;
    let best = parseInt(localStorage.getItem('tapup_best') || '0', 10);
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    scoreEl.textContent = score;
    bestEl.textContent = best;

    let running = false;
    let gameOver = false;

    // UI overlay elements
    const overlay = document.getElementById('overlay');
    const startCard = document.getElementById('startCard');
    const howCard = document.getElementById('howCard');
    const gameOverCard = document.getElementById('gameOverCard');
    const finalScoreEl = document.getElementById('finalScore');

    const showOverlay = (card) => {
      overlay.hidden = false;
      startCard.hidden = true; howCard.hidden = true; gameOverCard.hidden = true;
      card.hidden = false;
    };

    const hideOverlay = () => { overlay.hidden = true; };

    // Buttons
    document.getElementById('playBtn').onclick = () => { startGame(); };
    document.getElementById('howBtn').onclick = () => { showOverlay(howCard); };
    document.getElementById('howPlayBtn').onclick = () => { startGame(); };
    document.getElementById('backBtn').onclick = () => { showOverlay(startCard); };
    document.getElementById('retryBtn').onclick = () => { startGame(); };
    document.getElementById('menuBtn').onclick = () => { showOverlay(startCard); };
    document.getElementById('resetBestBtn').onclick = () => {
      localStorage.removeItem('tapup_best');
      best = 0; bestEl.textContent = '0';
    };

    // Start at menu
    showOverlay(startCard);

    function resetBall() {
      ball.x = LOGICAL_W/2;
      ball.y = LOGICAL_H * 0.45;
      ball.vx = 0; ball.vy = -6;
      ball.spin = 0; ball.angle = 0;
    }

    function startGame() {
      score = 0; scoreEl.textContent = '0';
      gameOver = false; running = true;
      hideOverlay();
      resetBall();
    }

    function endGame() {
      running = false; gameOver = true;
      finalScoreEl.textContent = String(score);
      if (score > best) { best = score; localStorage.setItem('tapup_best', String(best)); bestEl.textContent = String(best); }
      showOverlay(gameOverCard);
    }

    // Input handling (mouse/touch/pointer)
    const getCanvasPos = (evt) => {
      const rect = canvas.getBoundingClientRect();
      const cx = (evt.clientX - rect.left) * (LOGICAL_W / rect.width);
      const cy = (evt.clientY - rect.top) * (LOGICAL_H / rect.height);
      return { x: cx, y: cy };
    };

    const kick = (px, py) => {
      if (!running) return;
      const dx = px - ball.x;
      const dy = py - ball.y;
      const dist = Math.hypot(dx, dy);
      const hitRadius = ball.r * 1.2; // forgiving hitbox
      if (dist <= hitRadius) {
        // Strength scales with proximity to center
        const centerFactor = Math.max(0.6, 1 - (dist / hitRadius));
        const baseUp = 8.5; // upward impulse
        ball.vy = - (baseUp * centerFactor);
        // Sideways nudge from horizontal offset; capped
        ball.vx += Math.max(-5, Math.min(5, dx * 0.06));
        // Add spin proportional to tangential component
        ball.spin += Math.max(-0.2, Math.min(0.2, dx * 0.002));
        score++; scoreEl.textContent = String(score);
        // Small pop effect
        popFX(ball.x, ball.y);
      } else {
        // Miss: do nothing—if you miss too often, gravity wins :)
      }
    };

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const p = getCanvasPos(e);
      kick(p.x, p.y);
    }, { passive: false });

    // Prevent touch scrolling when interacting
    document.addEventListener('touchmove', (e) => { if (e.target === canvas) e.preventDefault(); }, { passive: false });

    // Simple FX particles
    const particles = [];
    function popFX(x, y) {
      for (let i = 0; i < 8; i++) {
        particles.push({ x, y, vx: (Math.random()-0.5)*2, vy: -Math.random()*2-0.5, life: 22 });
      }
    }

    function drawParticles() {
      for (let i = particles.length-1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.vy += 0.08; p.life -= 1;
        ctx.globalAlpha = Math.max(0, p.life/22);
        ctx.fillStyle = '#b7e1ff';
        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        if (p.life <= 0) particles.splice(i,1);
      }
    }

    function drawGround() {
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(20, groundY + 0.5);
      ctx.lineTo(LOGICAL_W-20, groundY + 0.5);
      ctx.stroke();
      ctx.restore();
    }

    function drawSoccerBall() {
      const { x, y, r } = ball;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(ball.angle);

      // Base ball
      ctx.fillStyle = '#f5f7fb';
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 2; ctx.stroke();

      // Simple stylized pentagon and panels (not geometrically perfect—good enough!)
      ctx.fillStyle = '#111826';
      const pentR = r * 0.45;
      ctx.beginPath();
      for (let i=0;i<5;i++){
        const ang = -Math.PI/2 + i * (Math.PI*2/5);
        const px = Math.cos(ang) * pentR;
        const py = Math.sin(ang) * pentR;
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath(); ctx.fill();

      ctx.strokeStyle = '#111826'; ctx.lineWidth = 2;
      for (let i=0;i<5;i++){
        const ang = -Math.PI/2 + i * (Math.PI*2/5);
        const px = Math.cos(ang) * pentR;
        const py = Math.sin(ang) * pentR;
        ctx.beginPath(); ctx.moveTo(px,py); ctx.lineTo(Math.cos(ang)*r*0.95, Math.sin(ang)*r*0.95); ctx.stroke();
      }

      ctx.restore();
    }

    function physics() {
      // Integrate
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.vy += gravity;
      ball.angle += ball.spin;

      // Horizontal bounds with gentle bounce
      if (ball.x - ball.r < 12) { ball.x = 12 + ball.r; ball.vx *= -0.5; ball.spin *= 0.7; }
      if (ball.x + ball.r > LOGICAL_W - 12) { ball.x = LOGICAL_W - 12 - ball.r; ball.vx *= -0.5; ball.spin *= 0.7; }

      // Ground check
      if (ball.y + ball.r >= groundY) {
        ball.y = groundY - ball.r;
        endGame();
      }
    }

    function drawBackground() {
      // Simple vignette
      const g = ctx.createRadialGradient(LOGICAL_W/2, LOGICAL_H*0.4, 60, LOGICAL_W/2, LOGICAL_H/2, LOGICAL_H*0.9);
      g.addColorStop(0, 'rgba(108, 192, 255, 0.08)');
      g.addColorStop(1, 'rgba(108, 192, 255, 0.00)');
      ctx.fillStyle = g; ctx.fillRect(0,0,LOGICAL_W,LOGICAL_H);
    }

    function render() {
      // Clear
      ctx.clearRect(0,0,LOGICAL_W,LOGICAL_H);
      drawBackground();
      drawGround();
      drawParticles();
      drawSoccerBall();
    }

    function loop() {
      if (running) physics();
      render();
      requestAnimationFrame(loop);
    }
    loop();
  })();
  </script>
</body>
</html>
